/*	Scene Update
	=============
	- Begin each update by walking the hiearchy to discover active nodes/components - push into per-component type lists to be updated (these lists should be accessible to other systems e.g. BasicRenderer).
	- Phased update required to ensure that operations happen in the right order.
		Animation - Pre-physics does all skeleton updates, transforms are copies to the relevant physics bodies.
		          - Post-phsyics does any IK, etc. after the physics step (handle collisions, etc.).

		Physics   - Run physics step, copy transforms back into the scene nodes.
		          - NB can't support hierarchical transforms between physics bodies (enforce in editor). Use constraints instead.

		Hierarchy - Update transforms in the scene hiearchy.
		          - Need to run before physics to ensure kinematics are resolved.
		          - *Also* need to run after physics to update any children of physics nodes - need a dirty flag.

	  Considering the above, scene update should proceed as follows:

		0. Walk scene to discover active nodes + components.	
		1. Animation pre-physics (all final poses should be *local*). Basic XForm modifiers should run here, too.
		2. Hierarchical transform update.
		3. Physics.
		4. Animation post-physics.
		5. Hierarchical transform udpate.

	  Note that the hierarchical transform update should probably happen by adding nodes to a list when their world transform is set, then traversing their children.


	Scene Serialization
	===================
	- Used for load/save + editor functionality (undo/redo, duplication).
	- Loading/restoring:
		
		1. Serialize/init - Allocate the object and serialize its members. This needs to function during undo/redo as well, so existing objects must check if the 
		   incoming serialized values require any re-initialization (e.g. don't re-load textures if the path didn't change).
		2. Reference resolution - all objects exist at this point, can resolve all GUID references to ptrs.
			- See GUIDs below for how this will work.
		3. Post init - any additional initialization which requires external ptrs (e.g. init physics constraints).

	- Saving:
	
		1. For each unique scene path, walk its node hierarchy and serialize objects. Stop traversal when reaching external references, serialize the path only.

	- Note that nested sub-scenes require a 'proxy' node in the parent scene hiearchy - the root of the sub-scene is a child of the proxy (this simplifies a lot of stuff).
	  For non-editor applications, could load the root node into the proxy to avoid the overhead.
	- Need to detect scene recursion during loading!
	- Need to keep a list of all unique scene instances and their save state - this would also be useful for propagating changes between scene instances.
		- Propagating changes should also work via serialization.

		
	UIDs
	====
	- Nodes within a single scene are assigned unique, persistent IDs.
	- Nested scenes are referenced via an augmented hierarchical ID which is generated during initialization.
	- Nodes may only reference other nodes within the local scene or lower in the hierarchy.
	- Reference resolution:
		- Each scene object acts as a 'context' for resolving node references.
		- During serialization, maintain a stack of scene objects.
			- Scene has a map of all nodes beneath it, with unique IDs generated by combining the *local* node ID with a *global* ID relative to the root.
		- During reference resolution, walk the hierarchy again - nodes resolve references by lookup into the context stack top.
			- Local references remain local within their scene (global part of the UID is 0).
			- Once a scene's node map is built, merge it up into the parent (local IDs get a global part from the containing node's local ID).
	- Generating UIDs:
		- Local UIDs are generated by the editor. On first load the editor finds the max existing ID and adds 1.
		- Global UIDs are generated after a subscene is loaded - the subscene's global node map is merged up into the parents. At this point, all global IDs from
		  subscene must be augmented with the subscene's local ID (probably by hash-combining). 

	Use cases
	=========
	- NB stuff marked ** is sort of optional - e.g. propagating changes to other scene instances, which is basically an editor-only feature.
	- Load a scene:
		- Serialize each node.
			- Check the local UID first; if the ID is already in the local map, don't allocate a new node.
			- Set the node's global UID.
		- Purge local map to remove any old nodes which weren't serialized.
		- If a node serializes a sub-scene:
			- Need to 're-resolve' global references upwards. The global suffix won't change so can selectively update nodes in the new list.
			- Check for recursion by looking back up the scene ptr hierarchy to check that the current path hasn't already been serialized.
		- Resolve all child/parent node references (local nodes only).
	- Save a scene (editor only?):
		- Serialize each node (from the scene's list of local nodes).
		- Sub-scenes: only serialize the path.
	- Add a new node (editor only):
		- Create a new node parented to the current scene's root, assign a UID from the current scene.
		- Duplicate the node into all scene instances**.
		- Add new nodes to all relevant node lists.
	- Delete a node:
		- Delete node for all scene instances (+ call OnDelete).
		- Remove from all scene lists (recusrively up the hierarchy for all scene instances**).

	Node Event Callbacks
	====================
	- Global map of GUID -> callback 'listeners' per event.
	- *Not* used for hiearchy management = probably too expensive. 
	- OnDelete, OnTransform, OnHierarchyChange, OnInit?

	Scene Editor
	============
	- Separate to the scene class(es).
		- Editor 'proxies'.
	- Inline-edit components (tree nodes).
	- Simple duplication.
	- Undo/redo (via serialization?).
		- See here about stack management: https://mynameismjp.wordpress.com/2008/12/19/undo-and-redo/
		- Editor proxies have a 'beginEdit()' method which serializes a snapshot of the object being edited (including de-resolution of object ptrs to global IDs).
		- Snapshot is pushed onto a stack with the GUID of the object being edited.
		- Should NOT be hierarchical - don't want to snapshot all the children and components recursively. Therefore need to remove any recursion from the serialization
		  (load everything into a big map and patch up the refs/ptrs during postInit()). See "Serialization refactor" below.
		- Beware operations which might invalidate references - need to do a fixup which parses the entire world!
		- How to manage deletions?
		- Always call init() after serialization? May need to propagate changes to 
		
	

	Components
	==========
	- 'Super' components = group common component combos e.g. BasicRenderable + Physics, 
	- Simple auto system for initializing some components.
		- E.g. Physics component looks to see if there's a BasicRenderable and tries to find a .physgeo or an adjacent physics mesh.

*/
#pragma once

#include <frm/core/AppSample3d.h>

typedef frm::AppSample3d AppBase;

class SceneTest: public AppBase
{
public:
	SceneTest();
	virtual ~SceneTest();

	virtual bool init(const frm::ArgList& _args) override;
	virtual void shutdown() override;
	virtual bool update() override;
	virtual void draw() override;

protected:

	frm::BasicRenderer* m_basicRenderer = nullptr;
};
